<script src="three.min.js"></script>
<script src="waterway.js"></script>
<script src="wave.js"></script>
<script>
var width=800,height=600;
var waveSize=32;
var wavePixels=256;
var scale=20;
onload=function(){
  camera = new THREE.Camera();
  camera = new THREE.PerspectiveCamera(40, width / height, 0.1, 1000);
  camera.position.z = 4;
  camera.lookAt({x:0,y:0,z:0});
  camera.initialRotation=camera.rotation.clone()
  scene = new THREE.Scene();
  mapmaterial = mapShader();
  wallshader1 = WaveSimulator.waveMultShader();
  wallshader1.uniforms.value.value=new THREE.Vector4(0,0,1,1);
  wallshader2 = WaveSimulator.waveAddShader();
  wallshader2.uniforms.value.value=new THREE.Vector4(0.5,0.5,0,1);

  itemWaveShader1 = WaveSimulator.waveMultShader();
  itemWaveShader2 = WaveSimulator.waveAddShader();
  itemWaveShader1.uniforms.value.value=new THREE.Vector4(1,1,0,1);
  itemWaveShader2.uniforms.value.value=new THREE.Vector4(0,0,0.5,1);

  chara = gondolaMesh();
  undine = new Undine(mapmaterial);
  undine.meshes.forEach(function(m){scene.add(m)});
  chara.material = mapmaterial;
  scene.add(chara);
  wavePattern = THREE.ImageUtils.loadTexture('texture/wave.jpg');
  sky = THREE.ImageUtils.loadTexture('texture/sky.jpg');
  wavePattern.wrapS = wavePattern.wrapT = THREE.RepeatWrapping;
  plane = new THREE.Mesh(new THREE.PlaneGeometry(waveSize, waveSize), WaveSimulator.renderShader(wavePixels));
  mapmaterial.uniforms.pattern.value=wavePattern;
  plane.material.uniforms.pattern.value=wavePattern;
  plane.material.uniforms.sky.value=sky;
  scene.add(plane);
  renderer = new THREE.WebGLRenderer();
  simulator = new WaveSimulator(wavePixels, renderer);
  renderer.setClearColor(new THREE.Color(0xaaaaaa));
  renderer.setSize(800,600);
  var $game=document.querySelector('#game');
  $game.appendChild(renderer.domElement);
  (window.onresize=function(){
    var w=window.innerWidth;
    var h=window.innerHeight;
    var s=Math.min(w/800,h/600);
    $game.style.transform=[
      'translate('+(w/2)+'px,'+(h/2)+'px)',
      'scale('+s+','+s+')',
      'translate(-400px,-300px)',
    ].join(' ')
  })()
  animate();
}
var Key={LEFT:37,UP:38,RIGHT:39,DOWN:40,map:{}};
document.onkeydown=function(e){
  Key.map[e.keyCode]=true;
}
document.onkeyup=function(e){
  Key.map[e.keyCode]=false;
}
var pos={x:0,y:0,th:Math.PI/2,rot:0,vx:0,vy:0,r:1,shape:[
  {x:0,y:-0.5,r:0.35},
  {x:0,y:-0.25,r:0.45},
  {x:0,y:-0.05,r:0.5},
  {x:0,y:0.05,r:0.5},
  {x:0,y:+0.25,r:0.45},
  {x:0,y:+0.5,r:0.35},
],
  roll: {th: 0, dth: 0}
}
var camth=pos.th;
var damage=0;
var state='start'
var chunkSize=4
var numChunks=1;
var chunks = {};
var items = []
function animate(){
  var time=performance.now()/1000;
  simulator.storeLoad();
  var arr1=simulator.readStoredPixel('chara1');
  var arr2=simulator.readStoredPixel('chara2');
  var arr3=simulator.readStoredPixel('chara3');
  var arr4=simulator.readStoredPixel('chara4');
  simulator.storePixel('chara1',(((pos.x+1)/waveSize%1+1)%1)*wavePixels,((pos.y/waveSize%1+1)%1)*wavePixels);
  simulator.storePixel('chara2',(((pos.x-1)/waveSize%1+1)%1)*wavePixels,((pos.y/waveSize%1+1)%1)*wavePixels);
  simulator.storePixel('chara3',((pos.x/waveSize%1+1)%1)*wavePixels,(((pos.y+1)/waveSize%1+1)%1)*wavePixels);
  simulator.storePixel('chara4',((pos.x/waveSize%1+1)%1)*wavePixels,(((pos.y-1)/waveSize%1+1)%1)*wavePixels);
  simulator.storeDone();
  if(arr1&&arr2){
    var hx=arr1[2]-arr2[2],hy=arr3[2]-arr4[2];
    pos.roll.dth+=0.2*(Math.cos(pos.th)*hy-Math.sin(pos.th)*hx)
    pos.vx=pos.vx*0.99-(arr1[0]+arr2[0]+arr3[0]+arr4[0]-2)*0.0002;
    pos.vy=pos.vy*0.99-(arr1[1]+arr2[1]+arr3[1]+arr4[1]-2)*0.0002;
    pos.rot=pos.rot*0.99+(arr1[1]-arr2[1]-arr3[0]+arr4[0])*0.001;
  }
  var chunkx=Math.round(pos.x/chunkSize/scale);
  var chunky=Math.round(pos.y/chunkSize/scale);
  for(var key in chunks)chunks[key].count++;
  for(var i=chunkx-numChunks;i<=chunkx+numChunks;i++){
    for(var j=chunky-numChunks;j<=chunky+numChunks;j++){
      var chunk = chunks[[i,j]];
      if(!chunk){
        console.log('gen',i,j);
        chunk=chunks[[i,j]]=new WaterwayChunk(i,j,chunkSize,scale,scene);
        chunk.mesh.material=mapmaterial;
        chunk.trimesh1.material=wallshader1;
        chunk.trimesh2.material=wallshader2;
        chunk.items.forEach(function(item){
          item.wave1.material=itemWaveShader1
          item.wave2.material=itemWaveShader2
        })
      }
      chunk.count=0;
    }
  }
  var oldchunks=Object.keys(chunks).map(function(key){return chunks[key]});
  oldchunks.sort(function(a,b){return a.count-b.count});
  while(oldchunks.length>(2*numChunks+2)*(2*numChunks+2)){
    var chunk = oldchunks.pop();
    delete chunks[[chunk.i,chunk.j]];
    chunk.dispose();
    scene.remove(chunk.mesh);
  }

  for(var key in chunks){
    var count = chunks[key].update(pos);
  }

  if(Key.map[Key.LEFT])pos.rot+=0.01;
  if(Key.map[Key.RIGHT])pos.rot-=0.01;
  if(damage==0){
    var v=(Key.map[Key.UP]?1:0)-(Key.map[Key.DOWN]?1:0);
    pos.vx+=Math.cos(pos.th)*0.004*v;
    pos.vy+=Math.sin(pos.th)*0.004*v;
  }
  var cos=Math.cos(pos.th),sin=Math.sin(pos.th);
  var pvx=(cos*pos.vx+sin*pos.vy)*cos*0.99+0.96*(-cos*pos.vy+sin*pos.vx)*sin;
  var pvy=(cos*pos.vx+sin*pos.vy)*sin*0.99-0.96*(-cos*pos.vy+sin*pos.vx)*cos;
  pos.vx=pvx;
  pos.vy=pvy;
  var triangles=[];
  for(var key in chunks){
    triangles.push.apply(triangles,chunks[key].triangles);
  }
  var pvr=Math.sqrt(pvx*pvx+pvy*pvy);
  var hitTriangles = triangles.filter(function(tri){
    return hitTest(tri,{x:pos.x,y:pos.y},pos.r+pvr+0.01);
  })
  var hit=false;
  var cos=Math.cos(pos.th),sin=Math.sin(pos.th);
  hitTriangles.forEach(function(tri){
    pos.shape.forEach(function(p){
      var c={x:pos.x+p.y*cos-p.x*sin,y:pos.y+p.y*sin+p.x*cos};
      if(!hit)hit=triInside(tri,c)||hitTest(tri,c,p.r);
    })
  })
  var dt=1;
  function test(){
    var cos=Math.cos(pos.th+pos.rot*dt),sin=Math.sin(pos.th+pos.rot*dt);
    var hits = [], hit=false;
    hitTriangles.forEach(function(tri){
      pos.shape.forEach(function(p){
        var c={x:pos.x+pos.vx*dt+p.y*cos-p.x*sin,y:pos.y+pos.vy*dt+p.y*sin+p.x*cos};
        if(triInside(tri,c))hit=true;
        var n=hitTest(tri,c,p.r);
        if(n)hits.push({
          pos: {x:p.y*cos-p.x*sin,y:p.y*sin+p.x*cos},
          normal: n,
          r: p.r
        });
      });
    });
    if(hits.length==0&&!hit)return null;
    return hits;
  }
  var hits = test();
  if(hits){
    var dtok=0;
    var dtng=1;
    for(var j=0;j<100;j++){
      dt=(dtok+dtng)/2;
      hits=test();
      if(hits)dtng=dt;
      else dtok=dt;
    }
    dt=dtng;
    hits = test(dtng);
    dt=dtok;
  }else{
    dt=1;
  }
  pos.x+=pos.vx*dt;pos.y+=pos.vy*dt;
  pos.th+=pos.rot*dt;
  dt=0;
  tmphits=test();
  if(hits){
    for(var k=0;k<1;k++){
      var hoge=0;
      hits.forEach(function(h){
        var hp={x:h.pos.x+h.normal.x*h.r,y:h.pos.y+h.normal.y*h.r};
        var hv={x:pos.vx-hp.y*pos.rot,y:pos.vy+hp.x*pos.rot};
        var vn=hv.x*h.normal.x+hv.y*h.normal.y;
        if(vn>-0.0){hoge++;
          console.log('EEE',h.pos.x*h.normal.x+h.pos.y*h.normal.y);
          var pr=Math.sqrt(hp.x*hp.x+hp.y*hp.y);

          var vpush=hv.x*h.pos.x+hv.y*h.pos.y;
          var vrot=hv.x*h.pos.y-hv.y*h.pos.x;

          var vf=(h.normal.x*hp.x+h.normal.y*hp.y)/pr;
          var rf=h.normal.x*hp.y-h.normal.y*hp.x;
          pos.vx-=1.5*(vn+0.0)*h.normal.x*vf;
          pos.vy-=1.5*(vn+0.0)*h.normal.y*vf;
          pos.rot+=rf/4;
        }
        pos.roll.dth+=2*Math.random()-1;
      });
      if(hoge==0)break;
    }
    console.log(k)
  }
  damage=Math.max(damage-0.02,0);
  chara.position.x=pos.x;
  chara.position.y=pos.y;
  chara.setRotationFromAxisAngle({x:0,y:0,z:1},pos.th);
  pos.roll.dth-=0.2*(Math.cos(pos.th)*pos.vy-Math.sin(pos.th)*pos.vx);
  pos.roll.dth*=0.99;pos.roll.th*=0.99;
  pos.roll.dth/=Math.max(1,Math.abs(pos.roll.dth));
  pos.roll.th/=Math.max(1,Math.abs(pos.roll.th));
  pos.roll.th+=pos.roll.dth*0.1;
  pos.roll.dth-=pos.roll.th*0.1;

  undine.update({x:pos.x,y:pos.y,z:1}, pos.th, pos.roll.th, 0.3, -0.5);

  chara.rotateX(pos.roll.th);
  pos.rot*=0.8;
  camth=camth*0.8+pos.th*0.2;
  camera.position.x=camera.position.x*0.8+0.2*(pos.x-1*Math.cos(pos.th))
  camera.position.y=camera.position.y*0.8+0.2*(pos.y-1*Math.sin(pos.th))
  camera.position.z=camera.position.z*0.95+0.05*(Key.map[27]?512:20);
  camera.setRotationFromAxisAngle({x:1,y:0,z:0},0)
  camera.rotateZ(camth-Math.PI/2)
  camera.rotateX(0.2);
  plane.position.x=pos.x;
  plane.position.y=pos.y;
  simulator.disturb({
    center: new THREE.Vector2((pos.x/waveSize%1+1)%1,(pos.y/waveSize%1+1)%1),
    overwrite: 1,
    radius: 0.02,
    scale: new THREE.Vector4(0.99,0.99,0.99,0.999),
    value: new THREE.Vector4(-pos.vx*4,-pos.vy*4,0,0)
  })
  simulator.calc();
  renderer.autoClear=false;
  scene.children.forEach(function(mesh){
    mesh.wasvisible=mesh.visible;
    mesh.visible=!!mesh.wall1||!!mesh.wall2;
  })
  var cornerPos={
    x:Math.round(wavePixels*(pos.x/waveSize+0.5)),
    y:Math.round(wavePixels*(pos.y/waveSize+0.5))
  };
  var centerPos={x:cornerPos.x-wavePixels/2,y:cornerPos.y-wavePixels/2};
  var cpi={
    x:(cornerPos.x%wavePixels+wavePixels)%wavePixels,
    y:(cornerPos.y%wavePixels+wavePixels)%wavePixels
  }
  renderer.setViewport(0,0,cpi.x,cpi.y);
  var wcamera = new THREE.OrthographicCamera(-cpi.x*waveSize/wavePixels,0,0,-cpi.y*waveSize/wavePixels,0,-1000,1000);
  wcamera.position.x=cornerPos.x*waveSize/wavePixels;
  wcamera.position.y=cornerPos.y*waveSize/wavePixels;
  renderer.render(scene, wcamera, simulator.wave);

  itemWaveShader2.uniforms.value.value.z=0.5+0.1*Math.sin(4*time);

  renderer.setViewport(0,cpi.y,cpi.x,wavePixels-cpi.y);
  var wcamera = new THREE.OrthographicCamera(-cpi.x*waveSize/wavePixels,0,waveSize-cpi.y*waveSize/wavePixels,0,-1000,1000);
  wcamera.position.x=cornerPos.x*waveSize/wavePixels;
  wcamera.position.y=cornerPos.y*waveSize/wavePixels-waveSize;
  renderer.render(scene, wcamera, simulator.wave);

  renderer.setViewport(cpi.x,0,wavePixels-cpi.x,cpi.y);
  var wcamera = new THREE.OrthographicCamera(0,waveSize-cpi.x*waveSize/wavePixels,0,-cpi.y*waveSize/wavePixels,-1000,1000);
  wcamera.position.x=cornerPos.x*waveSize/wavePixels-waveSize;
  wcamera.position.y=cornerPos.y*waveSize/wavePixels;
  renderer.render(scene, wcamera, simulator.wave);

  renderer.setViewport(cpi.x,cpi.y,wavePixels-cpi.x,wavePixels-cpi.y);
  var wcamera = new THREE.OrthographicCamera(0,waveSize-cpi.x*waveSize/wavePixels,waveSize-cpi.y*waveSize/wavePixels,0,-1000,1000);
  wcamera.position.x=cornerPos.x*waveSize/wavePixels-waveSize;
  wcamera.position.y=cornerPos.y*waveSize/wavePixels-waveSize;
  renderer.render(scene, wcamera, simulator.wave);  

  renderer.setViewport(0,0,width,height)
  scene.children.forEach(function(mesh){
    mesh.visible=mesh.wasvisible;
  });

  plane.material.uniforms.size.value=waveSize;
  plane.material.uniforms.time.value=time;
  plane.material.uniforms.wave.value=simulator.wave;
  var brightness=1+0.1*(
    Math.sin(13.7*time)+Math.sin(7.3*time)+Math.sin(10.3*time)+Math.sin(11.3*time));
  mapmaterial.uniforms.lightColor.value=new THREE.Vector3(
    0.5*brightness,
    0.3*brightness,
    0
  );
  mapmaterial.uniforms.time.value=time;
  mapmaterial.uniforms.lightPosition.value=new THREE.Vector3(pos.x+Math.cos(pos.th),pos.y+Math.sin(pos.th),1.2);
  renderer.render(scene, camera);
  requestAnimationFrame(animate);
}

function triInside(tri, p){
  var da={x:tri[1].x-tri[0].x,y:tri[1].y-tri[0].y};
  var db={x:tri[2].x-tri[0].x,y:tri[2].y-tri[0].y};
  var area=Math.abs(da.x*db.y-da.y*db.x);
  var area2=0;
  for(var i=0;i<3;i++){
    var a=tri[i],b=tri[(i+1)%3];
    area2+=Math.abs((a.x-p.x)*(b.y-p.y)-(a.y-p.y)*(b.x-p.x));
  }
  return (area2-area)/area<0.0001;
}
function hitTest(tri,p,r){
  var min,pos;
  for(var i=0;i<tri.length;i++){
    var a=tri[i],b=tri[(i+1)%3];
    var dx=b.x-a.x,dy=b.y-a.y;
    var x=a.x-p.x,y=a.y-p.y;
    var dd=dx*dx+dy*dy;
    var dc=dx*x+dy*y;
    var cc=x*x+y*y;
    var t=-dc/dd;
    if(t<0)t=0;if(t>1)t=1;
    var r2=dd*t*t+2*dc*t+cc;
    if((!pos||r2<min)&&r2<r*r){
      pos={x: x+t*dx, y: y+t*dy};
      min=r2;
    }
  }
  if(!pos)return null;
  var pr=Math.sqrt(pos.x*pos.x+pos.y*pos.y);
  return {x: pos.x/pr, y: pos.y/pr}
}

mapShader = function(){
  return new THREE.ShaderMaterial({
    uniforms: {
      lightPosition: {type: "v3"},
      pattern: {type: "t"},
      time: {type: "f"},
      lightColor: {type: "v3"}
    },
    vertexShader: WaveSimulator.shaderCode(arguments.callee, 'VERT'),
    fragmentShader: WaveSimulator.shaderCode(arguments.callee, 'FRAG'),
  });
  /*VERT
  varying vec3 gpos, norm;
  void main(){
    gpos=(modelMatrix*vec4(position,1)).xyz;
    norm=normalize((modelMatrix*vec4(normal,0)).xyz);
    gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1);
  }
  */
  /*FRAG
  varying vec3 gpos, norm;
  uniform vec3 lightPosition, lightColor;
  uniform sampler2D pattern;
  uniform float time;
  void main(){
    vec3 ldif=gpos-lightPosition;
    float lr=dot(ldif,ldif);

    float lval1=max(-dot(norm,ldif),0.0)/(1.0+lr*lr*0.05);
    float lval2=0.5+0.5*dot(norm,vec3(1,1,1));

    vec3 i3=vec3(1,1,1);
    float a=0.1,b=0.07;
    float c1=dot(texture2D(pattern,a*gpos.xy-b*gpos.yz+vec2(+0.1,0.0)*time).rgb-0.5,i3);
    float c2=dot(texture2D(pattern,a*gpos.yz-b*gpos.zx+vec2(-0.05,+0.1)*time).rgb-0.5,i3);
    float c3=dot(texture2D(pattern,a*gpos.zx-b*gpos.xy+vec2(-0.05,-0.1)*time).rgb-0.5,i3);

    float caustics = 1.0/(1.0+32.0*c1*c1)+1.0/(1.0+32.0*c2*c2)+1.0/(1.0+32.0*c3*c3);

    gl_FragColor.rgb=lightColor*lval1+lval2*vec3(0.05,0.05,0.1)+caustics*lval1*vec3(0.1,0.1,0.2);
    gl_FragColor.a=1.0;
  }
  */
}


</script>
<style>
canvas{position:absolute;left:0px;top:0px;}
#game{position:fixed;}
body{background:black;overflow:hidden;}
</style>
<div id='game'></div>
